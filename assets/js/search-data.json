{
  
    
        "post0": {
            "title": "Homework/Hacks for Sections 17-18",
            "content": "HACK 1 . HACK 2 . HACK 3 . HACK 4 . HACK 5 . HACK 6 . HACK 7 . HACK 8: Rewrite this JavaScript Code in a More Efficient Way (Hint: Use Binary Search) . function peak_finder(array){ let counter = 0 let peak = 0 let peak_index =0 while (counter &lt;= array.length){ console.log(counter) if (counter === 0){ if (a[0]&gt;=a[1]){ peak = a[0] peak_index = counter counter = array.length return `The ${counter-1} indexed number, ${peak} is a peak` }else{ counter+=1 } }else if(counter === array.length-1){ if (a[array.length-1] &gt;= a[array.length-2]){ peak = a[array.length-1] peak_index = counter counter = array.length return `The ${counter-1} indexed number, ${peak} is a peak` } }else{ if (a[counter]&gt; a[counter+1] &amp;&amp; a[counter]&gt; a[counter-1]){ peak = a[counter] peak_index = counter counter = array.length return `The ${counter-1} indexed number, ${peak} is a peak` }else{ counter += 1 } } } } . HACK 9: Rewrite this Python Code in a More Efficient Way . def merge_sort(data): if len(data) &lt;= 1: return mid = len(data) // 2 left_data = data[:mid] right_data = data[mid:] merge_sort(left_data) merge_sort(right_data) left_index = 0 right_index = 0 data_index = 0 while left_index &lt; len(left_data) and right_index &lt; len(right_data): if left_data[left_index] &lt; right_data[right_index]: data[data_index] = left_data[left_index] left_index += 1 else: data[data_index] = right_data[right_index] right_index += 1 data_index += 1 if left_index &lt; len(left_data): del data[data_index:] data += left_data[left_index:] elif right_index &lt; len(right_data): del data[data_index:] data += right_data[right_index:] if __name__ == &#39;__main__&#39;: data = [9, 1, 7, 6, 2, 8, 5, 3, 4, 0] merge_sort(data) print(data) . HACK 10: Rewrite this Python Code in a More Efficient Way . def heap_permutation(data, n): if n == 1: print(data) return for i in range(n): heap_permutation(data, n - 1) if n % 2 == 0: data[i], data[n-1] = data[n-1], data[i] else: data[0], data[n-1] = data[n-1], data[0] if __name__ == &#39;__main__&#39;: data = [1, 2, 3] heap_permutation(data, len(data)) .",
            "url": "https://vardaansinha.github.io/fastpagesp4/jupyter/2022/12/12/HACKS.html",
            "relUrl": "/jupyter/2022/12/12/HACKS.html",
            "date": " • Dec 12, 2022"
        }
        
    
  
    
        ,"post1": {
            "title": "3.18 Undecidable Problems",
            "content": "Learning objective . Explain the existence of undecidable problems in computer science. Basically What are undecidable problems in comp sci? . Main idea: There exist problems that computers cannot solve, and even when a computer can solve a problem, it may not be able to do so in a reasonable amount of time. . Essential knowledge . What is a decidable problem? . These are problems for which algorthms could be written to solve/produce a correct output for all inputs. . num = 4 if num % 2 == 0: # divides num by 2 and checks remainder. print(&quot;is even&quot;) # if remainder is 0, num is even else: print(&quot;is not even&quot;) # if there is any remainder e.g its odd num: num is odd # all inputs will provide a yes or no answer . is even . What is an undecidable problem? . These are problems for which no algorithms can be built that can provide a correct yes or no answer. . Also... . Undecidable problems may have some instances of algorithmic solutions, but there are no algorithmic solutions that can solve all instances of the problem (zeem) . IMPORTANT!!!! . Don&#39;t worry about determining if a given problem is undecidable or not. deciding if problems are undecideable or not is outside the scope of APCSP. Worry about that later in advanced CS courses . Undecidable problem example . # given a computer program and an input... # will the program terminate or will it run forever? x = input() while x: pass # this reads the input, # and if it&#39;s not empty, the procedure loops forever. . The Halting problem is probably the best known problem that has proven to be undecidable. that is, no program can solve the Halting problem for sufficiently general computer programs. . def fumo(): a = 0 i = 1 while a != 1: i = i + 1 print(i) fumo() # this is a good example of the halting problem . Theoretical example (by zeem) . Barber Paradox: There was a barber in a small town on Crick Island, and one day he made a rule that he would only cut the hair of people who did not cut their own hair. The barber&#39;s rule seemed to make sense, since people cut their own hair, so I do not have to &quot;do more than that&quot;, I will give this person a haircut. Initially, there was nothing wrong with this rule, but later, as the barber&#39;s own hair grew longer and longer, he found himself in a dilemma: should he give himself a haircut? . Answer: If he cuts his own hair, then he becomes the &quot;person who cuts his own hair&quot; in his regulations, then he should not cut his own hair; if he does not cut his own hair, then he is not the one in his regulations A person who cuts his own hair&quot;, then he should cut his own hair. Combining the above two situations, &quot;he cuts his own hair&quot; if and only if &quot;he does not cut his own hair&quot;, which becomes a paradox. . essential vocabulary . vocab term definition . undecidable problem | problems for which no algorithms can be built that can provide a correct yes or no answer or a solution | . Decidable problem | problems for which algorthms could be written to solve/produce a correct output for all inputs. | . practice problems . questions: . Question 1: can there be some algorithmic solutions for some inputs/instances of a undecidable problem? . Question 1.5: Are there algorithmic solutions for all inputs/instances of an undecidable problem? . Question 2: Is the following problem undecidable or decidable? . Problem: is the number given by user input greater than 20? . Question 3: the following algorithm solves the problem below. is the problem decidable or undecidable? . Problem: are there more different kinds of fruits in stock or more different kinds of vegetables in stock? . fruits = [&quot;apples&quot;, &quot;pears&quot;, &quot;apricot&quot;, &quot;tomatos&quot;] vegetables = [&quot;carrot&quot;, &quot;cauliflower&quot;, &quot;beets&quot;] if len(fruits) &gt; len(vegetables): print(&quot;yes&quot;) else: print(&quot;no&quot;) . yes . Question 4: God is omnipotent, so can God create a stone that he cannot lift? Why or why not? (zeem) . ANSWERS: true, false, decidable, decidable .",
            "url": "https://vardaansinha.github.io/fastpagesp4/jupyter/2022/12/11/3.18.html",
            "relUrl": "/jupyter/2022/12/11/3.18.html",
            "date": " • Dec 11, 2022"
        }
        
    
  
    
        ,"post2": {
            "title": "3.17 Algorithmic Efficiency: Part 2",
            "content": "Learning objective . AAP-4.A.5 . An algorithm’s efficiency can be informally measured by determining the number of times a statement or group of statements executes. . AAP-4.A.6 . Different correct algorithms for the same problem can have different efficiencies. . AAP-4.A.7 . Algorithms with a polynomial efficiency or slower (constant, linear, square, cube, etc.) are said to run in a reasonable amount of time. Algorithms with exponential or factorial efficiencies are examples of algorithms that run in an unreasonable amount of time. . AAP-4.A.8 . Some problems cannot be solved in a reasonable amount of time because there is no efficient algorithm for solving them. In these cases, approximate solutions are sought. . AAP-4.A.7 . Categorizing run times . We can categorize the run time of an algorithm according to how the number of steps increases as the input size increases. Does it always take the same amount of time? That&#39;s a constant increase, a very fast run time. Does it always require looking at every possible permutation of the input? That&#39;s an exponential increase, a very slow run time. Most run times are somewhere between. . Constant time When an algorithm runs in constant time, it means that it always takes a fixed number of steps, no matter how large the input size increases. As an example, consider accessing the first element of a list: . firstPost ← posts[1] . Even if the list grows to be a million items long, that operation will always require a single step. . Now imagine this code&#39;s result as a table? A graph? What would it look like? (In terms of List size vs Steps) . Reasonable Time . Algorithms with a polynomial efficiency or lower (constant, linear, square, cube, etc.) . Ex: . n^2 | 2n | n | n^10 | n^20 | log(n) | . Unreasonable Time . Algorithms with exponential or factorial efficiencies . Ex: . 2^n | 10^n | 5^n | .",
            "url": "https://vardaansinha.github.io/fastpagesp4/jupyter/2022/12/11/3.17part2.html",
            "relUrl": "/jupyter/2022/12/11/3.17part2.html",
            "date": " • Dec 11, 2022"
        }
        
    
  
    
        ,"post3": {
            "title": "3.17 Algorithmic Efficiency: Part 1",
            "content": "Learning Objectives (3.17) . For determining the efficiency of an algorithm: . Explain the difference between algorithms that run in reasonable time and those that do not. | . Essential Knowledge (3.17 Part 1) &amp; Vocabulary . A problem is a description of a task that may or may not be able to be solved through the use of an algorithm. An instance of a problem includes a specific input. One example of this type of problem is a sorting problem. | A decision problem is a problem with a binary answer (yes or no). An optimization problem is a problem with the objective of finding the BEST solution amongst many possibilities to solve a problem. | An algorithm&#39;s efficiency is determine through formal or mathematical reasoning. | . Learning Example #1 (Follow Along): . One example of a sorting problem as referenced in the above key ideas involves a collection of 4 cards. The objective of this problem is to order the cards from least to greatest value, and there are many different algorithms to do this. . Algorithm #1 . In algorithm #1, the program repeatedly compares two elements in an array of values that are right next to each other, and then swaps them if they are in the wrong order. . In this case, the numbers were 4, 5, 7, and 2 (in that order). The code would look a little like this (notice the bubble sort that was covered by another group!): . def bubbleSort(arr): n = len(arr) for i in range(n): for j in range(0, n - i - 1): if arr[j] &gt; arr[j + 1]: arr[j], arr[j + 1] = arr[j + 1], arr[j] arr = [4, 5, 7, 2] bubbleSort(arr) print(&quot;Here is your sorted array:&quot;) for i in range(len(arr)): print(&quot;%d&quot; % arr[i]) . Here is your sorted array: 2 4 5 7 . Now, the above code worked. According to calculations though, this algorithm would take 7 comparisons (comparisons are where the two cards next to each other are compared), and 3 swaps (swaps are seen in lines 6 and 7 of the above program, where if a descending card has a greater value than the next card, the two cards are swapped). . So, in accordance to the main points of this unit, we have to establish a sense of algorithmic efficiency, and create an algorithm that takes less steps and still accomplishes the task. . Algorithm #2: . In this algorithm, the program keeps finding the minimum element in the defined array, and it keeps sorting it in order. For each iteration of the program, the minimum element is compared with the next card, and then swapped if necessary. . Now, let&#39;s see how this program works: . def selectionSort(array,value): for step in range(value): min_element = step for i in range(step + 1, value): if array[i] &lt; array[min_element]: min_element = i (array[step], array[min_element]) = (array[min_element], array[step]) cards = [4, 5, 7, 2] value = len(cards) selectionSort(cards,value) print(&quot;Here is your sorted array:&quot;) print(cards) . Here is your sorted array: [2, 4, 5, 7] . This code ALSO worked. But, in comparison to the first algorithm, this algorithm took less comparisons and less swaps. . In the next part of our lesson, we&#39;ll be talking about HOW we can quantify algorithmic efficiency in a variety of manners. . Check for Understanding: . As discussed in the essential knowledge, there are problems that can or cannot be solved algorithmically. Which of the following options provides a problem that cannot be solved with a computer algorithm? | A. You are in an elevator with other people and you have to find a route for different floors requested by people in the elevator. . B. Sorting decks of cash amounts. Each deck has a different cash amount, and the decks need to be ordered from greatest to least. . C. Finding the best possible route to get from one corner of a computer maze to the other corner while avoiding defined obstacles. . D. All of the following can be solved with algorithms. . Answer [The answer would be option A. Though you might be able to find the best route for a set number of people to get to their floor, but at each floor that the elevator stops, new people may get on, people may get off on accident, etc, so there is a limit to how much you can optimize the problem with an algorithm.]",
            "url": "https://vardaansinha.github.io/fastpagesp4/jupyter/2022/12/11/3.17part1.html",
            "relUrl": "/jupyter/2022/12/11/3.17part1.html",
            "date": " • Dec 11, 2022"
        }
        
    
  

  
  

  
      ,"page1": {
          "title": "About Me",
          "content": "This website is powered by fastpages 1. . a blogging platform that natively supports Jupyter notebooks in addition to other formats. &#8617; . |",
          "url": "https://vardaansinha.github.io/fastpagesp4/about/",
          "relUrl": "/about/",
          "date": ""
      }
      
  

  

  
  

  

  
  

  

  
  

  
  

  
  

  
  

  
      ,"page11": {
          "title": "",
          "content": "Sitemap: {{ “sitemap.xml” | absolute_url }} | .",
          "url": "https://vardaansinha.github.io/fastpagesp4/robots.txt",
          "relUrl": "/robots.txt",
          "date": ""
      }
      
  

}